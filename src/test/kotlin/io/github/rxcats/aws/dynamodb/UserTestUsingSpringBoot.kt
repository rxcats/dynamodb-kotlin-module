package io.github.rxcats.aws.dynamodb

import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.stereotype.Repository
import software.amazon.awssdk.enhanced.dynamodb.Key
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedTimestampAttribute
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior
import io.github.rxcats.aws.dynamodb.extensions.DynamoDbKtTableName
import java.time.Instant
import kotlin.test.Test

@DynamoDbKtTableName("Users")
data class User(
    @get:DynamoDbPartitionKey
    val pk: String = "",

    val name: String = "",

    @get:DynamoDbAutoGeneratedTimestampAttribute
    @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
    val updatedAt: Instant = Instant.EPOCH,

    @get:DynamoDbAutoGeneratedTimestampAttribute
    @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
    val createdAt: Instant = Instant.EPOCH,
) {
    fun key(): Key = Key.builder().partitionValue(pk).build()
}

@Repository
class UserRepository : SimpleDynamoDbRepository<User>(User::class)

@SpringBootTest(classes = [DynamoDbTestConfiguration::class])
class UserRepositoryTest {
    private val log by loggerK

    @Autowired
    private lateinit var repository: UserRepository

    companion object {
        @JvmStatic
        @BeforeAll
        fun beforeAll(@Autowired repo: UserRepository) {
            repo.createTable()

            val user = User(
                pk = "tester#1001",
                name = "tester",
            )

            repo.save(user)
        }

        @JvmStatic
        @AfterAll
        fun afterAll(@Autowired repo: UserRepository) {
            repo.deleteTable()
        }
    }

    @Test
    fun getItemTest() {
        val user = repository.getItem(Key.builder().partitionValue("tester#1001").build())
        assertThat(user).isNotNull()
        assertThat(user?.createdAt).isAfter(Instant.EPOCH)
        assertThat(user?.updatedAt).isAfter(Instant.EPOCH)
    }

    @Test
    fun transactionGetItemTest() {
        val user = repository.transactionGetItem(Key.builder().partitionValue("tester#1001").build())
        assertThat(user).isNotNull()
        assertThat(user?.createdAt).isAfter(Instant.EPOCH)
        assertThat(user?.updatedAt).isAfter(Instant.EPOCH)
    }

    @Test
    fun transactionTest() {
        val samples = listOf(
            User(pk = "tester#2001", name = "2001"),
            User(pk = "tester#2002", name = "2002"),
        )
        repository.transactionSaveItems(samples)

        val after = repository.transactionGetItemsByKeys(samples.map { it.key() })
        assertThat(after).hasSize(samples.size)

        repository.transactionDeleteItemsByKeys(samples.map { it.key() })

        val deletedItems = repository.transactionGetItemsByKeys(samples.map { it.key() })
        assertThat(deletedItems).hasSize(samples.size)

        deletedItems.forEach {
            assertThat(it).isNull()
        }
    }

    @Test
    fun batchTest() {
        val samples = listOf(
            User(pk = "tester#3001", name = "3001"),
            User(pk = "tester#3002", name = "3002"),
        )
        repository.batchSaveItems(samples)

        val after = repository.batchGetItems(samples.map { it.key() })
        assertThat(after).hasSize(samples.size)

        repository.batchDeleteByKeys(samples.map { it.key() })

        val deletedItems = repository.batchGetItems(samples.map { it.key() })
        assertThat(deletedItems).isEmpty()
    }
}
